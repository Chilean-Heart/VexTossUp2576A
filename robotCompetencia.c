#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in2,    midLine,        sensorLineFollower)
#pragma config(Sensor, in3,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in8,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  upButton,       sensorTouch)
#pragma config(Sensor, dgtl2,  downButton,     sensorTouch)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  midButton,      sensorTouch)
#pragma config(Sensor, dgtl9,  led4x,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, led2x,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, led1x,          sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  liftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftRearMotor, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftFrontMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftLiftMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           leftIntake,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightIntake,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLiftMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightFrontMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightRearMotor, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Competition type
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

//Debug variables.
//#define DEBUG
//#define PID_NULL
#define AUTO_NULL
#define AUTO_TEST

//Max and min arm values.
#define MAX_ARM_VALUE 3180
#define MIN_ARM_VALUE 1350
#define MID_ARM_VALUE ((MIN_ARM_VALUE + MAX_ARM_VALUE) / 2) + 100

//PID constants.
#ifdef PID_NULL
const float Kp = 0;
const float Ki = 0;
const float Kd = 0;
#else
const float Kp = 0.55;
const float Ki = 0;
const float Kd = 0.005;
#endif

//Declare and initialize PID errors and operation outputs.
int kErr = 0, prevKErr = 0, iErr = 0, dErr = 0;
float kOut = 0, iOut = 0, dOut = 0;
//Declare and initialize PID output.
int output = 0;
//PID target and sensor values.
int targetValue = MIN_ARM_VALUE + 100, potOutput = 0;

//Select drive
bool tankDrive = true;
//Auto counter
int autoCounter = 3;
//Auto skip variable
bool autoSkip = false;
//Intake state
short intakeState = 0;
//Check battery level
bool checkBattery = false;

//Limit max motor power
int limitMotorOutput(int value){
	value = value > 127 ? 127 : value;
	value = value < -127 ? -127 : value;
	return value;
}

//Remaps the output power curve of the motors in the drivetrain. Allows for a lineal accelaration and control instead
//of the normal exponential curve. Equation: y = a * b^x
int linearDrive(int power){
	#define DEADBAND 10
	#define a 20
	#define b 1.0146611
	if(abs(power) <= DEADBAND){
		power = 0;
	}
	int regulated = a * pow(b, abs(power));
	regulated *= sgn(power);
	return limitMotorOutput(regulated);
}

//Drive function to control motors in the chassis.
void setMotorsWCD(int leftPower, int rightPower){
	motor[rightFrontMotor] = rightPower;
	motor[rightRearMotor] = rightPower;
	motor[leftFrontMotor] = leftPower;
	motor[leftRearMotor] = leftPower;
}

//Function to control the lift motors that regulate the 6-bar mechanism.
void setLift(int power){
	motor[rightLiftMotor] = limitMotorOutput(power);
	motor[leftLiftMotor] = limitMotorOutput(power);
}

//Function to control the intake motors.
void setIntake(int power){
	motor[leftIntake] = limitMotorOutput(power);
	motor[rightIntake] = limitMotorOutput(power);
}

//Set 3 leds on robot to display binary representation of current auto mode.
void autoLeds(int number){
	if(number == 0){
		SensorValue[led1x] = false;
		SensorValue[led2x] = false;
		SensorValue[led4x] = false;
	}
	else if(number == 1){
		SensorValue[led1x] = true;
		SensorValue[led2x] = false;
		SensorValue[led4x] = false;
	}
	else if(number == 2){
		SensorValue[led1x] = false;
		SensorValue[led2x] = true;
		SensorValue[led4x] = false;
	}
	else if(number == 3){
		SensorValue[led1x] = true;
		SensorValue[led2x] = true;
		SensorValue[led4x] = false;
	}
	else if(number == 4){
		SensorValue[led1x] = false;
		SensorValue[led2x] = false;
		SensorValue[led4x] = true;
	}
	else if(number == 5){
		SensorValue[led1x] = true;
		SensorValue[led2x] = false;
		SensorValue[led4x] = true;
	}
	else if(number == 6){
		SensorValue[led1x] = false;
		SensorValue[led2x] = true;
		SensorValue[led4x] = true;
	}
	else if(number == 7){
		SensorValue[led1x] = true;
		SensorValue[led2x] = true;
		SensorValue[led4x] = true;
	}
	wait1Msec(20);
}

//Check current battery level
task batteryLevel(){
	if(checkBattery){
		int battery = nAvgBatteryLevel;
		if(battery > 7000){
			autoLeds(7);
		}
		else if(battery > 6000){
			autoLeds(3);
		}
		else if(battery > 5000){
			autoLeds(1);
		}
	}
	else{
		autoLeds(0);
	}
	wait1Msec(30);
}


//Check current drive mode. Switches between arcade and tank.
task checkDrive(){
	while(true){
		if(vexRT[Btn7D]){
			tankDrive = !tankDrive;
			wait1Msec(50);
		}
		wait1Msec(30);
	}
}

//PID Loop. Runs every 10 ms to control lift mechanism based on a target value from 0-1200. Use Btn6U and Btn6D to control target.
task pidLoop(){
	while(true){
		potOutput = SensorValue[liftPot];

		kErr = targetValue - potOutput;
		iErr += kErr;
		dErr = kErr - prevKErr;

		kOut = Kp * kErr;
		iOut = Ki * iErr;
		dOut = Kd * dErr;

		prevKErr = kErr;

		output = kOut + iOut + dOut;
		output = limitMotorOutput(output);
		setLift(output);
		wait1Msec(10);
	}
}

//Task to check buttons on Joystick. Add an if loop for every button macro/preset used.
task checkPresets(){
	while(true){
		if(vexRT[Btn6U]){
			targetValue = MID_ARM_VALUE;
			wait1Msec(5);
		}
		if(vexRT[Btn6D]){
			targetValue = MIN_ARM_VALUE;
			wait1Msec(5);
		}
		if(vexRT[Btn5U]){
			intakeState = 2;
			wait1Msec(5);
		}
		if(vexRT[Btn5D]){
			intakeState = 1;
			wait1Msec(5);
		}
		if(vexRT[Btn7U]){
			intakeState = 0;
			wait1Msec(5);
		}
		if(vexRT[Btn8L]){
			checkBattery = true;
			wait1Msec(5);
		}
		if(!vexRT[Btn8L]){
			checkBattery = false;
			wait1Msec(5);
		}
		else{
			wait1Msec(5);
		}
	}
}


//TODO: Correct false output from the PID loop when using this function.
//Task to average potentiometer output on the lift arm. Takes 10 readings every 1 ms and averages them at
//the end of the 10 ms period.
task potAverage(){
	while(true){
		int averagingPot;
		//Average 10 pot values taken every 2 ms. TODO: Use semaphores for locking value.
		for(int i = 0; i < 10; i++){
			averagingPot += SensorValue[liftPot];
			wait1Msec(1);
		}
		potOutput = (averagingPot / 10);
		potOutput = potOutput > MIN_ARM_VALUE ? MIN_ARM_VALUE : potOutput;
		potOutput = potOutput < MAX_ARM_VALUE ? MAX_ARM_VALUE : potOutput;
		wait1Msec(1);
	}
}

//Check buttons on back of robot to update PID target. Runs every 10 ms (5ms for check + 5ms delay).
#ifdef DEBUG
task checkButtons(){
	while(true){
		if(SensorValue[upButton]){
			targetValue += 10;
			wait1Msec(5);
		}
		if(SensorValue[downButton]){
			targetValue -= 10;
			wait1Msec(5);
		}
		targetValue = targetValue > MAX_ARM_VALUE ? MAX_ARM_VALUE : targetValue;
		targetValue = targetValue < MIN_ARM_VALUE ? MIN_ARM_VALUE : targetValue;
		wait1Msec(5);
	}
}
//If DEBUG isn't defined, use joystick controls to update target.
#else
task updateTarget(){
	while(true){
		if(vexRT[Btn8U]){
			targetValue += 10;
			wait1Msec(5);
		}
		if(vexRT[Btn8D]){
			targetValue -=10;
			wait1Msec(5);
		}
		targetValue = targetValue > MAX_ARM_VALUE ? MAX_ARM_VALUE : targetValue;
		targetValue = targetValue < MIN_ARM_VALUE ? MIN_ARM_VALUE : targetValue;
		wait1Msec(5);
	}
}
#endif

//Control intake
task intake(){
	while(true){
		if(intakeState == 2){
			setIntake(127);
			wait1Msec(10);
		}
		else if(intakeState == 1){
			setIntake(-127);
			wait1Msec(10);
		}
		else if(intakeState == 0){
			setIntake(0);
			wait1Msec(10);
		}
		wait1Msec(10);
	}
}

//Empty auto
void auto0(){

}

//Empty auto
void auto1(){
	targetValue = MID_ARM_VALUE;
	wait1Msec(5);
	setLift(output);
	wait1Msec(100);
	setMotorsWCD(60, 60);
	wait1Msec(2000);
	setMotorsWCD(0, 0);
	wait1Msec(200);
	setMotorsWCD(-60, -60);
	wait1Msec(2000);
	setMotorsWCD(0, 0);
	wait1Msec(1000);
	setMotorsWCD(70, 70);
	wait1Msec(3000);
	setMotorsWCD(0, 0);
}

//ARM NEEDS TO BE ELEVATED IN AN ILLEGAL POSITION
//Drive forward, drop one large ball and push bucky ball.
void auto2(){
	setMotorsWCD(60, 60);
	wait1Msec(2000);
	setMotorsWCD(0, 0);
}

//Drop two large balls. Push buckyball beneath truss;
void auto3(){
	setLift(127);
	wait1Msec(1300);
	setLift(0);
	setMotorsWCD(60, 60);
	wait1Msec(2000);
	setMotorsWCD(0, 0);
	wait1Msec(200);
	setMotorsWCD(-60, -60);
	wait1Msec(2000);
	setMotorsWCD(0, 0);
	wait1Msec(1000);
	setMotorsWCD(70, 70);
	wait1Msec(3000);
	setMotorsWCD(0, 0);
}

//UNTESTED
//Drop bucky balls on bump
void auto4(){
	setMotorsWCD(110, 110);
	wait1Msec(1000);
	setMotorsWCD(70, -70);
	wait1Msec(500);
	setMotorsWCD(100, 100);
	wait1Msec(1000);
}

//UNUSED IN COMPETITION
//TESTED: BEWARE OF TIPPING
//Drop two large balls, push bucky ball and drive towards other alliance to push ball on bump and/or pin robot.
void auto5(){
	clearTimer(T1);
	while(time1[T1] <= 1300){
		setLift(127);
		setMotorsWCD(90, 90);
	}
	setLift(0);
	setMotorsWCD(0, 0);
	wait1Msec(200);
	setMotorsWCD(-90, -90);
	wait1Msec(600);
	setMotorsWCD(0, 0);
	wait1Msec(100);
	setMotorsWCD(100, -100);
	wait1Msec(300);
	setMotorsWCD(0, 0);
	wait1Msec(100);
	setMotorsWCD(110, 110);
	wait1Msec(700);
	setMotorsWCD(0, 0);
	wait1Msec(100);
	setMotorsWCD(-100, 100);
	wait1Msec(00);
	setMotorsWCD(0, 0);
	wait1Msec(100);
	setMotorsWCD(110, 110);
	wait1Msec(700);
	setMotorsWCD(0, 0);
	wait1Msec(100);
	setMotorsWCD(-90, -90);
	wait1Msec(700);
	setMotorsWCD(0, 0);
	wait1Msec(100);
	setMotorsWCD(100, -100);
	wait1Msec(250);
	setMotorsWCD(0, 0);
	wait1Msec(100);
	clearTimer(T1);
	while(time1[T1] < 500){
		setLift(-127);
		setMotorsWCD(127, 127);
	}
	setLift(0);
	wait1Msec(4000);
	setMotorsWCD(0, 0);
}

//Empty Auto
void auto6(){

}

//Empty Auto
void auto7(){

}

//Execute auto function selected in preauto.
void autoPlay(int auto){
	if(auto == 0){
		auto0();
	}
	else if(auto == 1){
		auto1();
	}
	else if(auto == 2){
		auto2();
	}
	else if(auto == 3){
		auto3();
	}
	else if(auto == 4){
		auto4();
	}
	else if(auto == 5){
		auto5();
	}
	else if(auto == 6){
		auto6();
	}
	else if(autoCounter == 7){
		auto7();
	}
}

//Pre-Autonomous preparation code
void pre_auton(){
	//Set to false to mantain user created task between auto and teleop
	bStopTasksBetweenModes = false;

	//Start tasks.
	startTask(pidLoop, 10); //Initialize PID loop task.

	//If DEBUG is defined, check bump buttons. If not, use Joystick.
	#ifdef DEBUG
	startTask(checkButtons); //For debugging of PID loop.
	#else
	startTask(updateTarget); //For lifting intake.
	#endif

	//startTask(potAverage);
	startTask(checkPresets);

	//Control intake motors
	startTask(intake);

	//Define drive type
	startTask(checkDrive);

	//Begin Battery Checker;
	startTask(batteryLevel);

	//Check to see if auto is not used
	#ifdef AUTO_NULL
	wait1Msec(1);
	#else
	//Wait to be enabled or for the auto skip button to be pressed.
	while(bIfiRobotDisabled || !autoSkip){
		//Change auto modes
		if(SensorValue[upButton]){
			autoCounter++;
			wait1Msec(100);
		}
		if(SensorValue[downButton]){
			autoCounter--;
			wait1Msec(100);
		}
		//Limit auto counter
		autoCounter = autoCounter > 7 ? 7 : autoCounter;
		autoCounter = autoCounter < 0 ? 0 : autoCounter;
		autoLeds(autoCounter);
		wait1Msec(10);
		//Read skip button
		autoSkip = (bool)SensorValue[midButton];
	}
	#endif
}

//Autonomous code
task autonomous(){
	autoPlay(autoCounter);
}

//Tele-op period
task usercontrol(){
	//Use when FMS is not available to test auto.
	#ifdef AUTO_TEST
	while(!autoSkip){
		//Change auto modes
		if(SensorValue[upButton]){
			autoCounter++;
			wait1Msec(100);
		}
		if(SensorValue[downButton]){
			autoCounter--;
			wait1Msec(100);
		}
		//Limit auto counter
		autoCounter = autoCounter > 7 ? 7 : autoCounter;
		autoCounter = autoCounter < 0 ? 0 : autoCounter;
		autoLeds(autoCounter);
		wait1Msec(10);
		//Read skip button
		autoSkip = (bool)SensorValue[midButton];
	}
	autoPlay(autoCounter);
	#endif
	//While loop. Keeps the robot running this code constantly.
	while(true){
		//Check drive type
		if(tankDrive){
			//Drive chassis in tank mode.
			setMotorsWCD(linearDrive(vexRT[Ch3]), linearDrive(vexRT[Ch2]));
		}
		else if(!tankDrive){
			//Drive chassis in arcade mode. Left is (y+x)/2 and right is (y-x)/2. Eliminated division by 2 to speed up motors.
			setMotorsWCD(linearDrive((vexRT[Ch2] + vexRT[Ch1])),
									 linearDrive((vexRT[Ch2] - vexRT[Ch1])) );
		}

		//Set the output of lift mechanism.
		//setLift(output);

		//Delay of loop. Needed to not hog the cpu.
		wait1Msec(10);
	}
}
